# 面向对象

[TOC]

```C++
//定义类
class 类名
{
  访问权限
    属性
    方法
};

//通过类创建一个具体的对象
类名 对象名;
```



## 一、访问权限：

`public` 公共权限 ---- 类外也可以使用     <u>struct 默认权限是公共</u>

`private` 私有权限 ---- 只有类内使用      <u>class默认权限是私有</u>

`protected` 保护权限  ---- 继承关系中使用

## 二、构造函数和析构函数：

若我们不提供构造函数和析构函数，编译器会自动为我们提供一个空的构造函数和析构函数

**构造函数：**`类名([形参列表]) {}`  

- 可以有参数，也可以没有，因此会发生重载

- 分类：有参构造和无参构造、普通构造和拷贝构造

  - 普通构造：`Person([形参列表]){}`	常规的构造形式就是普通构造
  - 拷贝构造：`Person(const Person &p){}`

- 调用：

  - 无参构造：`Person p;`	【注】调用无参构造时不能够添加'()'，编译器会误认为是函数声明
  - 有参构造：`Person p(实参列表);`
  - 拷贝构造：`Person oldP;  Person p(oldP);`
  - 显示调用方法：`Person p1 = Person([实参列表]); `
    - `Person([实参列表])`相当于是创建了匿名对象；特点：当前执行结束后，系统会立即回收掉匿名对象
    - 不要利用拷贝构造函数初始化匿名对象，编译器会认为是`Person(oldP) == Person oldP;`对象重定义
  - 隐式转换法：`Person p = 10;` 相当于是写了`Person p = Person(10);`    可调用拷贝构造

- 拷贝构造函数调用时机：

  - 使用一个已经创建完毕的对象来初始化一个新的对象

  - 值传递的方式给函数参数传值

    - ```C++
      void doWork(Person p) //进行了值传递
      { 
      	//由于采用的是值传递，所以传递给doWork函数的是p的一个副本，编译器会隐式的创建一个Person类对象，因此此时会调用Person类的拷贝构造函数 
      }		
      void test02()
      {
        Person p;		//调用了无参构造函数
        doWork(p);	
      }
      ```

    - ​

  - 以值方式返回局部对象

    - ```C++
      Person doWork()
      {
        Person p1;
        reutn p1;			
        //由于是值传递，因此这里返回的返回值并不是p1本身，而是p1的一个副本，编译器会隐式的创建一个Person类对象，因此此时会调用Person类的拷贝构造函数
        //并且编译器会销毁原来的p1，因此会调用Person的析构函数
      }
      void test03() 
      {
      	Person p = doWork();  
      }
      ```

- 构造函数调用规则：

  - 若用户定义有参构造函数，则C++不再提供无参构造函数，但是会提供默认的拷贝构造函数
  - 若用户定义拷贝构造函数，则C++不再提供其他的构造函数

**析构函数：**`~类名() {}`  不能够有参数，因此不能够发生重载

- 若用户没有定义析构函数，则C++不再提供默认的析构函数

## 三、初始化列表：

语法：`构造函数():属性1(值1),属性2(值2)...{}`

```C++
class Peerson
{
  int a;
  int b;
  int c;
  //传统的初始化对象属性
  Person(int a, int b, int c){
    this.a = a;
   	this.b = b;
    this.c = c;
  }
  //利用初始化列表的语法进行对对象属性赋值
  Person():a(10),b(20),c(30)
  {
    
  }
  //初始化列表与有参构造的结合：是的初始化属性的值变得更为灵活
  Person(int pa, int pb, int pc):a(pa), b(pb), c(pc)
  {
    
  }
}
```



## 四、类对象作为类成员

```C++
class A {};
class B
{
  A a;
};
```

当创建对象B时，A与B的构造函数和析构函数的顺序是谁先谁后？